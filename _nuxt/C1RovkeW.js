var H=Object.defineProperty;var F=(t,e,r)=>e in t?H(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var w=(t,e,r)=>F(t,typeof e!="symbol"?e+"":e,r);import{O as I,P as L,u as U,C as j,I as W,Q as v,R as G,S as Q,c as X,U as Y,V as Z,L as z,W as N,r as q,X as E,Y as J,Z as $,B as x,$ as K}from"./BBNW6-kU.js";const k=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],A=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],ee="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",B=[];class ae{constructor(){w(this,"_data",new P);w(this,"_hash",new P([...k]));w(this,"_nDataBytes",0);w(this,"_minBufferSize",0)}finalize(e){e&&this._append(e);const r=this._nDataBytes*8,s=this._data.sigBytes*8;return this._data.words[s>>>5]|=128<<24-s%32,this._data.words[(s+64>>>9<<4)+14]=Math.floor(r/4294967296),this._data.words[(s+64>>>9<<4)+15]=r,this._data.sigBytes=this._data.words.length*4,this._process(),this._hash}_doProcessBlock(e,r){const s=this._hash.words;let a=s[0],n=s[1],i=s[2],h=s[3],u=s[4],_=s[5],c=s[6],D=s[7];for(let o=0;o<64;o++){if(o<16)B[o]=e[r+o]|0;else{const d=B[o-15],y=(d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3,g=B[o-2],O=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;B[o]=y+B[o-7]+O+B[o-16]}const m=u&_^~u&c,l=a&n^a&i^n&i,f=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22),C=(u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25),b=D+C+m+A[o]+B[o],M=f+l;D=c,c=_,_=u,u=h+b|0,h=i,i=n,n=a,a=b+M|0}s[0]=s[0]+a|0,s[1]=s[1]+n|0,s[2]=s[2]+i|0,s[3]=s[3]+h|0,s[4]=s[4]+u|0,s[5]=s[5]+_|0,s[6]=s[6]+c|0,s[7]=s[7]+D|0}_append(e){typeof e=="string"&&(e=P.fromUtf8(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes}_process(e){let r,s=this._data.sigBytes/64;e?s=Math.ceil(s):s=Math.max((s|0)-this._minBufferSize,0);const a=s*16,n=Math.min(a*4,this._data.sigBytes);if(a){for(let i=0;i<a;i+=16)this._doProcessBlock(this._data.words,i);r=this._data.words.splice(0,a),this._data.sigBytes-=n}return new P(r,n)}}class P{constructor(e,r){w(this,"words");w(this,"sigBytes");e=this.words=e||[],this.sigBytes=r===void 0?e.length*4:r}static fromUtf8(e){const r=unescape(encodeURIComponent(e)),s=r.length,a=[];for(let n=0;n<s;n++)a[n>>>2]|=(r.charCodeAt(n)&255)<<24-n%4*8;return new P(a,s)}toBase64(){const e=[];for(let r=0;r<this.sigBytes;r+=3){const s=this.words[r>>>2]>>>24-r%4*8&255,a=this.words[r+1>>>2]>>>24-(r+1)%4*8&255,n=this.words[r+2>>>2]>>>24-(r+2)%4*8&255,i=s<<16|a<<8|n;for(let h=0;h<4&&r*8+h*6<this.sigBytes*8;h++)e.push(ee.charAt(i>>>6*(3-h)&63))}return e.join("")}concat(e){if(this.words[this.sigBytes>>>2]&=4294967295<<32-this.sigBytes%4*8,this.words.length=Math.ceil(this.sigBytes/4),this.sigBytes%4)for(let r=0;r<e.sigBytes;r++){const s=e.words[r>>>2]>>>24-r%4*8&255;this.words[this.sigBytes+r>>>2]|=s<<24-(this.sigBytes+r)%4*8}else for(let r=0;r<e.sigBytes;r+=4)this.words[this.sigBytes+r>>>2]=e.words[r>>>2];this.sigBytes+=e.sigBytes}}function te(t){return new ae().finalize(t).toBase64()}function de(t){return te(I(t))}const se={trailing:!0};function re(t,e=25,r={}){if(r={...se,...r},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let s,a,n=[],i,h;const u=(_,c)=>(i=ie(t,_,c),i.finally(()=>{if(i=null,r.trailing&&h&&!a){const D=u(_,h);return h=null,D}}),i);return function(..._){return i?(r.trailing&&(h=_),i):new Promise(c=>{const D=!a&&r.leading;clearTimeout(a),a=setTimeout(()=>{a=null;const o=r.leading?s:u(this,_);for(const m of n)m(o);n=[]},e),D?(s=u(this,_),c(s)):n.push(c)})}}async function ie(t,e,r){return await t.apply(e,r)}const ne=t=>t==="defer"||t===!1;function fe(...t){var m;const e=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&typeof t[0]!="object"&&!(typeof t[0]=="function"&&typeof t[1]=="function")&&t.unshift(e);let[r,s,a={}]=t;const n=j(()=>W(r));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const i=U();a.server??(a.server=!0),a.default??(a.default=le),a.getCachedData??(a.getCachedData=p),a.lazy??(a.lazy=!1),a.immediate??(a.immediate=!0),a.deep??(a.deep=v.deep),a.dedupe??(a.dedupe="cancel"),a._functionName,i._asyncData[n.value];const h=a.getCachedData(n.value,i,{cause:"initial"});(m=i._asyncData[n.value])!=null&&m._init||(i._asyncData[n.value]=V(i,n.value,s,a,h));const u=i._asyncData[n.value];u._deps++;const _=()=>i._asyncData[n.value].execute({cause:"initial",dedupe:a.dedupe}),c=a.server!==!1&&i.payload.serverRendered;{let l=function(d){const y=i._asyncData[d];y!=null&&y._deps&&(y._deps--,y._deps===0&&(y==null||y._off()))};const f=G();if(f&&c&&a.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const d=f._nuxtOnBeforeMountCbs;Q(()=>{d.forEach(y=>{y()}),d.splice(0,d.length)}),X(()=>d.splice(0,d.length))}const C=f&&(f._nuxtClientOnly||Y(Z,!1));c&&i.isHydrating&&(u.error.value||h!=null)?(u.pending.value=!1,u.status.value=u.error.value?"error":"success"):f&&!C&&(i.payload.serverRendered&&i.isHydrating||a.lazy)&&a.immediate?f._nuxtOnBeforeMountCbs.push(_):a.immediate&&_();const b=K();if(a.watch){const d=z(a.watch,()=>{u._execute({cause:"watch",dedupe:a.dedupe})},{flush:"post"});b&&N(()=>d())}const M=z(n,(d,y)=>{var O,S;const g=((O=i._asyncData[y])==null?void 0:O.data.value)!==v.value;y&&l(y),(S=i._asyncData[d])!=null&&S._init||(i._asyncData[d]=V(i,d,s,a,a.getCachedData(d,i,{cause:"initial"}))),i._asyncData[d]._deps++,(a.immediate||g)&&i._asyncData[d].execute({cause:"initial",dedupe:a.dedupe})},{flush:"sync"});b&&N(()=>{M(),l(n.value)})}const D={data:R(()=>{var l;return(l=i._asyncData[n.value])==null?void 0:l.data}),pending:R(()=>{var l;return(l=i._asyncData[n.value])==null?void 0:l.pending}),status:R(()=>{var l;return(l=i._asyncData[n.value])==null?void 0:l.status}),error:R(()=>{var l;return(l=i._asyncData[n.value])==null?void 0:l.error}),refresh:(...l)=>i._asyncData[n.value].execute(...l),execute:(...l)=>i._asyncData[n.value].execute(...l),clear:()=>T(i,n.value)},o=Promise.resolve(i._asyncDataPromises[n.value]).then(()=>D);return Object.assign(o,D),o}function R(t){return j({get(){var e;return(e=t())==null?void 0:e.value},set(e){const r=t();r&&(r.value=e)}})}async function he(t){await new Promise(r=>L(r)),await U().hooks.callHookParallel("app:data:refresh",void 0)}function T(t,e){e in t.payload.data&&(t.payload.data[e]=void 0),e in t.payload._errors&&(t.payload._errors[e]=v.errorValue),t._asyncData[e]&&(t._asyncData[e].data.value=void 0,t._asyncData[e].error.value=v.errorValue,t._asyncData[e].pending.value=!1,t._asyncData[e].status.value="idle"),e in t._asyncDataPromises&&(t._asyncDataPromises[e]&&(t._asyncDataPromises[e].cancelled=!0),t._asyncDataPromises[e]=void 0)}function ce(t,e){const r={};for(const s of e)r[s]=t[s];return r}function V(t,e,r,s,a){var D;(D=t.payload._errors)[e]??(D[e]=v.errorValue);const n=s.getCachedData!==p,i=r,h=s.deep?q:E,u=a!=null,_=t.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await c.execute({cause:"refresh:hook"})}),c={data:h(u?a:s.default()),pending:E(!u),error:J(t.payload._errors,e),status:E("idle"),execute:(o={})=>{if(t._asyncDataPromises[e]){if(ne(o.dedupe??s.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if(o.cause==="initial"||t.isHydrating){const l=o.cause==="initial"?a:s.getCachedData(e,t,{cause:o.cause??"refresh:manual"});if(l!=null)return t.payload.data[e]=c.data.value=l,c.error.value=v.errorValue,c.status.value="success",Promise.resolve(l)}c.pending.value=!0,c.status.value="pending";const m=new Promise((l,f)=>{try{l(i(t))}catch(C){f(C)}}).then(async l=>{if(m.cancelled)return t._asyncDataPromises[e];let f=l;s.transform&&(f=await s.transform(l)),s.pick&&(f=ce(f,s.pick)),t.payload.data[e]=f,c.data.value=f,c.error.value=v.errorValue,c.status.value="success"}).catch(l=>{if(m.cancelled)return t._asyncDataPromises[e];c.error.value=$(l),c.data.value=x(s.default()),c.status.value="error"}).finally(()=>{m.cancelled||(c.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=m,t._asyncDataPromises[e]},_execute:re((...o)=>c.execute(...o),0,{leading:!0}),_default:s.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{_(),c._init=!1,n||(T(t,e),c.execute=()=>Promise.resolve(),c.data.value=v.value)}};return c}const le=()=>v.value,p=(t,e,r)=>{if(e.isHydrating)return e.payload.data[t];if(r.cause!=="refresh:manual"&&r.cause!=="refresh:hook")return e.static.data[t]};export{de as h,he as r,fe as u};
